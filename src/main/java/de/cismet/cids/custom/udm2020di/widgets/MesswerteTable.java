/***************************************************
*
* cismet GmbH, Saarbruecken, Germany
*
*              ... and it just works.
*
****************************************************/
package de.cismet.cids.custom.udm2020di.widgets;

import org.apache.log4j.Logger;

import org.openide.util.NbBundle;

import java.awt.EventQueue;

import java.text.SimpleDateFormat;

import javax.swing.table.AbstractTableModel;

import de.cismet.cids.custom.udm2020di.types.AggregationValue;

/**
 * DOCUMENT ME!
 *
 * @author   Pascal Dih√©
 * @version  $Revision$, $Date$
 */
public class MesswerteTable extends javax.swing.JPanel {

    //~ Static fields/initializers ---------------------------------------------

    protected static final SimpleDateFormat DATE_FORMAT = new SimpleDateFormat("dd.MM.YYYY");
    protected static final Logger LOGGER = Logger.getLogger(MesswerteTable.class);

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JScrollPane jScrollPane;
    private javax.swing.JTable messwerteTable;
    // End of variables declaration//GEN-END:variables

    //~ Constructors -----------------------------------------------------------

    /**
     * Creates new form MesswerteTable.
     */
    public MesswerteTable() {
        initComponents();
    }

    //~ Methods ----------------------------------------------------------------

    /**
     * DOCUMENT ME!
     *
     * @param  aggregationValues  DOCUMENT ME!
     */
    public void setAggregationValues(final AggregationValue[] aggregationValues) {
        if (LOGGER.isDebugEnabled()) {
            LOGGER.debug("Initializing MesswerteTableModel with "
                        + aggregationValues.length + " aggregation Values");
        }

        final MesswerteTableModel messwerteTableModel = new MesswerteTableModel(aggregationValues);

        final Runnable r = new Runnable() {

                @Override
                public void run() {
                    messwerteTable.setModel(messwerteTableModel);
                }
            };

        if (EventQueue.isDispatchThread()) {
            r.run();
        } else {
            EventQueue.invokeLater(r);
        }
    }

    /**
     * This method is called from within the constructor to initialize the form. WARNING: Do NOT modify this code. The
     * content of this method is always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {
        jScrollPane = new javax.swing.JScrollPane();
        messwerteTable = new javax.swing.JTable();

        setLayout(new java.awt.BorderLayout());

        messwerteTable.setBorder(javax.swing.BorderFactory.createLineBorder(
                javax.swing.UIManager.getDefaults().getColor("Table.dropLineColor")));
        messwerteTable.setModel(new javax.swing.table.DefaultTableModel(
                new Object[][] {},
                new String[] {
                    "Parametername",
                    "Maximalwert",
                    "gemessen am",
                    "Minimalwert",
                    "gemessen am",
                    "Einheit"
                }) {

                Class[] types = new Class[] {
                        java.lang.String.class,
                        java.lang.Float.class,
                        java.lang.String.class,
                        java.lang.Float.class,
                        java.lang.String.class,
                        java.lang.String.class
                    };
                boolean[] canEdit = new boolean[] { false, false, false, false, false, false };

                @Override
                public Class getColumnClass(final int columnIndex) {
                    return types[columnIndex];
                }

                @Override
                public boolean isCellEditable(final int rowIndex, final int columnIndex) {
                    return canEdit[columnIndex];
                }
            });
        messwerteTable.setFillsViewportHeight(true);
        messwerteTable.setPreferredSize(new java.awt.Dimension(300, 500));
        messwerteTable.setRequestFocusEnabled(false);
        messwerteTable.getTableHeader().setReorderingAllowed(false);
        jScrollPane.setViewportView(messwerteTable);

        add(jScrollPane, java.awt.BorderLayout.CENTER);
    } // </editor-fold>//GEN-END:initComponents

    //~ Inner Classes ----------------------------------------------------------

    /**
     * DOCUMENT ME!
     *
     * @version  $Revision$, $Date$
     */
    class MesswerteTableModel extends AbstractTableModel {

        //~ Instance fields ----------------------------------------------------

        private final AggregationValue[] aggregationValues;

        //~ Constructors -------------------------------------------------------

        /**
         * Creates a new MesswerteTableModel object.
         *
         * @param  aggregationValues  DOCUMENT ME!
         */
        MesswerteTableModel(final AggregationValue[] aggregationValues) {
            this.aggregationValues = aggregationValues;
        }

        //~ Methods ------------------------------------------------------------

        /**
         * DOCUMENT ME!
         *
         * @return  DOCUMENT ME!
         */
        @Override
        public int getRowCount() {
            return (aggregationValues != null) ? aggregationValues.length : 0;
        }

        /**
         * DOCUMENT ME!
         *
         * @return  DOCUMENT ME!
         */
        @Override
        public int getColumnCount() {
            return 6;
        }

        /**
         * DOCUMENT ME!
         *
         * @param   rowIndex     DOCUMENT ME!
         * @param   columnIndex  DOCUMENT ME!
         *
         * @return  DOCUMENT ME!
         */
        @Override
        public Object getValueAt(final int rowIndex, final int columnIndex) {
            if ((aggregationValues != null)
                        && (rowIndex < aggregationValues.length)) {
                switch (columnIndex) {
                    case 0: {
                        return aggregationValues[rowIndex].getPlainName();
                    }
                    case 1: {
                        return aggregationValues[rowIndex].getMaxValue();
                    }
                    case 2: {
                        return DATE_FORMAT.format(aggregationValues[rowIndex].getMaxDate());
                    }
                    case 3: {
                        return aggregationValues[rowIndex].getMinValue();
                    }
                    case 4: {
                        return DATE_FORMAT.format(aggregationValues[rowIndex].getMinDate());
                    }
                    case 5: {
                        return aggregationValues[rowIndex].getUnit();
                    }
                    default: {
                        return null;
                    }
                }
            } else {
                LOGGER.warn("invalid row index: " + rowIndex);
                return null;
            }
        }

        /**
         * DOCUMENT ME!
         *
         * @param   column  DOCUMENT ME!
         *
         * @return  DOCUMENT ME!
         */
        @Override
        public String getColumnName(final int column) {
            switch (column) {
                case 0: {
                    return NbBundle.getMessage(MesswerteTable.class,
                            "MesswerteTable.MesswerteTableModel.column_0");
                }
                case 1: {
                    return NbBundle.getMessage(MesswerteTable.class,
                            "MesswerteTable.MesswerteTableModel.column_1");
                }
                case 2: {
                    return NbBundle.getMessage(MesswerteTable.class,
                            "MesswerteTable.MesswerteTableModel.column_2");
                }
                case 3: {
                    return NbBundle.getMessage(MesswerteTable.class,
                            "MesswerteTable.MesswerteTableModel.column_3");
                }
                case 4: {
                    return NbBundle.getMessage(MesswerteTable.class,
                            "MesswerteTable.MesswerteTableModel.column_4");
                }
                case 5: {
                    return NbBundle.getMessage(MesswerteTable.class,
                            "MesswerteTable.MesswerteTableModel.column_5");
                }
                default: {
                    return "unbekannt";
                }
            }
        }

        /**
         * DOCUMENT ME!
         *
         * @param   columnIndex  DOCUMENT ME!
         *
         * @return  DOCUMENT ME!
         */
        @Override
        public Class<?> getColumnClass(final int columnIndex) {
            switch (columnIndex) {
                case 0: {
                    return String.class;
                }
                case 1: {
                    return Float.class;
                }
                case 2: {
                    return String.class;
                }
                case 3: {
                    return Float.class;
                }
                case 4: {
                    return String.class;
                }
                case 5: {
                    return String.class;
                }
                default: {
                    return String.class;
                }
            }
        }
    }
}
